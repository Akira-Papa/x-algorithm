# Xアルゴリズム マスター講座 (第1章〜第3章)

> このガイドでは、Xの「For You」フィードを動かすレコメンデーションアルゴリズムについて、先生と生徒の対話形式で解説します。実際のソースコードに基づいた正確な情報を提供します。

---

## 第1章: Xアルゴリズムの基本を理解する

### 1.1 For Youフィードとは何か

**生徒**: 先生、Xを開くと「For You」というタブがありますが、あのフィードはどうやって作られているんですか？

**先生**: いい質問だね。「For You」フィードは、Xのレコメンデーションシステムの中核を成すものだよ。簡単に言うと、**あなたが興味を持ちそうな投稿を自動的に選んで、最適な順番で並べてくれる仕組み**なんだ。

**生徒**: でも、どうやって「興味を持ちそう」って分かるんですか？

**先生**: それがまさにアルゴリズムの仕事なんだ。Xのシステムは「Phoenix」と呼ばれるGrokベースのトランスフォーマーモデルを使っていてね。このモデルが**あなたの過去の行動パターン**を分析して、各投稿に対する反応を予測するんだよ。

**生徒**: 過去の行動パターンって、具体的には何ですか？

**先生**: 例えば：
- どの投稿に「いいね」したか
- どの投稿にリプライしたか
- どの投稿をリツイートしたか
- どの投稿をクリックして読んだか
- どの投稿でスクロールを止めて長く見たか

こういった**エンゲージメント履歴**を全部分析しているんだ。

---

### 1.2 なぜアルゴリズムが重要なのか

**生徒**: 単純に時間順で表示すればいいんじゃないですか？

**先生**: それは良い疑問だね。実は、Xには毎日何億もの投稿が行われているんだ。もし時間順だけで表示したら、フォローしている人が多い場合、**本当に見たい投稿が埋もれてしまう**んだよ。

**生徒**: なるほど...

**先生**: さらに重要なのは、アルゴリズムが**あなたがまだフォローしていない人の投稿も発見させてくれる**ことなんだ。これが「アウトオブネットワーク」コンテンツと呼ばれるもので、新しい興味や新しいクリエイターとの出会いを生み出すんだよ。

**生徒**: アルゴリズムがないと、自分のバブルの中だけにいることになりそうですね。

**先生**: その通り！アルゴリズムは**情報の窓を広げてくれる**役割も果たしているんだ。

---

### 1.3 インネットワーク vs アウトオブネットワーク

**生徒**: 「インネットワーク」と「アウトオブネットワーク」という言葉が出てきましたが、詳しく教えてください。

**先生**: これはXアルゴリズムを理解する上で**最も重要な概念の一つ**だよ。

#### インネットワーク（In-Network）

**先生**: インネットワークコンテンツは、**あなたがフォローしているアカウントからの投稿**のことだ。Xでは「Thunder」というシステムがこれを担当していてね。

**生徒**: Thunderって何ですか？

**先生**: Thunderは**インメモリの投稿ストア**で、フォローしている人たちの最新投稿をリアルタイムで追跡しているんだ。特徴は：
- サブミリ秒（1000分の1秒以下）でデータを取得できる
- オリジナル投稿、リプライ、リポスト、動画投稿を別々に管理
- 保持期間を過ぎた古い投稿は自動的に削除される

**生徒**: めちゃくちゃ速いんですね！

#### アウトオブネットワーク（Out-of-Network）

**先生**: 一方、アウトオブネットワークコンテンツは、**あなたがまだフォローしていないアカウントからの投稿**だ。これは「Phoenix Retrieval」というML（機械学習）ベースの類似性検索で発見されるんだよ。

**生徒**: どうやって「似ている」って判断するんですか？

**先生**: Two-Towerモデルという仕組みを使うんだ：

1. **User Tower（ユーザータワー）**: あなたの特徴やエンゲージメント履歴を「埋め込みベクトル」に変換
2. **Candidate Tower（候補タワー）**: 全ての投稿を同じく「埋め込みベクトル」に変換
3. **類似性検索**: 2つのベクトルの「内積」を計算して、類似度の高い投稿を見つける

**生徒**: 数学的に「あなたに合いそうな投稿」を見つけているんですね。

**先生**: その通り！そして、インネットワークとアウトオブネットワークの候補が集まったら、**Phoenixモデルで一緒にランキング**されるんだ。

```
フィードの構成
├── インネットワーク（Thunder）
│   └── フォローしている人の投稿
└── アウトオブネットワーク（Phoenix Retrieval）
    └── MLで発見された投稿
```

**生徒**: 両方混ぜて、一番良い順に並べるんですね！

---

### 実践アドバイス: 第1章のまとめ

**先生**: ここで、この知識をどう活かすか話しておこう。

1. **フォロワーとの関係を大切に**: インネットワークのコンテンツは依然として重要。フォロワーからのエンゲージメントを増やすと、あなたの投稿がそのフォロワーのFor Youに表示されやすくなる。

2. **アウトオブネットワークでの発見を意識**: 良質なコンテンツを投稿すれば、Phoenix Retrievalによってあなたをフォローしていない人にも届く可能性がある。

3. **一貫したトピックが効果的**: アルゴリズムはユーザーの興味を学習するため、一貫したテーマで投稿すると、そのテーマに興味がある人に発見されやすくなる。

---

## 第2章: エンゲージメントの種類と重み

### 2.1 ポジティブエンゲージメント

**生徒**: 先生、「いいね」とか「リツイート」って、アルゴリズムにとってどれくらい重要なんですか？

**先生**: 非常に重要だよ。Phoenixモデルは**複数のエンゲージメントタイプの確率を同時に予測**しているんだ。実際のコードを見てみよう。

```rust
// PhoenixScores構造体（候補投稿のスコア）
pub struct PhoenixScores {
    // ポジティブエンゲージメント
    pub favorite_score: Option<f64>,      // いいね
    pub reply_score: Option<f64>,         // リプライ
    pub retweet_score: Option<f64>,       // リツイート
    pub quote_score: Option<f64>,         // 引用リツイート
    pub share_score: Option<f64>,         // シェア（全般）
    pub share_via_dm_score: Option<f64>,  // DMでシェア
    pub share_via_copy_link_score: Option<f64>, // リンクコピー

    // 閲覧関連
    pub click_score: Option<f64>,         // クリック
    pub photo_expand_score: Option<f64>,  // 写真の拡大
    pub profile_click_score: Option<f64>, // プロフィールクリック
    pub vqv_score: Option<f64>,           // 動画視聴
    pub quoted_click_score: Option<f64>,  // 引用元クリック
    pub dwell_score: Option<f64>,         // 滞在（停止）
    pub dwell_time: Option<f64>,          // 滞在時間
    pub follow_author_score: Option<f64>, // 著者をフォロー

    // ネガティブエンゲージメント
    pub not_interested_score: Option<f64>, // 興味なし
    pub block_author_score: Option<f64>,   // ブロック
    pub mute_author_score: Option<f64>,    // ミュート
    pub report_score: Option<f64>,         // 報告
}
```

**生徒**: こんなに種類があるんですね！

**先生**: そうなんだ。一つずつ見ていこう。

#### いいね（Favorite）

**先生**: いいねは**最も基本的なポジティブシグナル**だ。ワンタップで行える簡単なアクションだから、多くのユーザーが使う。

**生徒**: いいねが多いと、その投稿は他の人にも表示されやすくなりますか？

**先生**: 直接的にはそうじゃないんだ。重要なのは**「この投稿を見たユーザーが、いいねする確率が高い」とモデルが予測するかどうか**だよ。つまり、P(favorite)が高い投稿が優先される。

#### リプライ（Reply）

**先生**: リプライは**より深いエンゲージメントのシグナル**だ。文字を入力する手間がかかるから、本当に関心がある証拠になる。

**生徒**: いいねより価値があるんですか？

**先生**: 一般的にはそう考えられているね。ただし、具体的な重みは後で説明するよ。

#### リツイート（Repost）と引用リツイート（Quote）

**先生**: これらは**拡散のシグナル**だ。ユーザーが自分のフォロワーにも見せたいと思っているということだから。

**生徒**: 引用リツイートはリツイートより重要ですか？

**先生**: 引用リツイートはコメント付きだから、**より深い関与を示す**と言えるね。

#### シェア（Share, Share via DM, Share via Copy Link）

**先生**: シェアは**プラットフォーム外への拡散意図**を示すんだ。特に：
- `share_via_dm_score`: DMで友達に送る
- `share_via_copy_link_score`: リンクをコピーして他の場所で共有

これらは**投稿の価値を高く評価している証拠**だね。

#### 閲覧関連のエンゲージメント

**生徒**: クリックとか滞在時間も見ているんですね。

**先生**: そう。これらは**暗黙的なエンゲージメント**と呼ばれることもある：

- `click_score`: 投稿をクリックして詳細を見た
- `photo_expand_score`: 写真を拡大した
- `profile_click_score`: 著者のプロフィールを見た
- `vqv_score`: 動画を視聴した（Video Quality View）
- `dwell_score` / `dwell_time`: スクロールを止めて長く見た

**生徒**: ボタンを押さなくても、見ているだけで評価されるんですね。

**先生**: その通り！特に`dwell_time`（滞在時間）は**連続値として計測**されていて、単なるyes/noじゃない詳細なシグナルになっているんだ。

#### フォロー（Follow Author）

**先生**: `follow_author_score`は特別だよ。**投稿を見た後にその著者をフォローする確率**を予測している。

**生徒**: これが高い投稿は相当価値があるってことですね！

**先生**: その通り。新しいフォロワーを獲得できる可能性を示唆しているからね。

---

### 2.2 ネガティブエンゲージメント

**生徒**: ネガティブなエンゲージメントも予測しているんですか？

**先生**: 非常に重要な部分だよ。以下の4つがある：

```rust
pub not_interested_score: Option<f64>, // 「興味なし」
pub block_author_score: Option<f64>,   // ブロック
pub mute_author_score: Option<f64>,    // ミュート
pub report_score: Option<f64>,         // 報告
```

#### 興味なし（Not Interested）

**先生**: ユーザーが「この投稿に興味がない」とマークした場合だ。**最も軽いネガティブシグナル**だけど、明確な拒否の意思表示だね。

#### ブロック（Block Author）

**先生**: ブロックは**深刻なネガティブシグナル**だ。そのユーザーのコンテンツを二度と見たくないという強い意思表示だからね。

#### ミュート（Mute Author）

**先生**: ブロックほど強くないけど、**特定のアカウントからのコンテンツを見たくない**という意思表示だ。

#### 報告（Report）

**先生**: 報告は**最も深刻なネガティブシグナル**だ。投稿がルール違反だと思われている可能性を示す。

**生徒**: これらのネガティブなシグナルはスコアを下げるんですか？

**先生**: その通り！重み付け計算のときに**マイナスの重み**がかけられるんだ。次の章で詳しく説明するよ。

---

### 2.3 各アクションの相対的重要度

**生徒**: 結局、どのアクションが一番重要なんですか？

**先生**: これは重要なポイントだね。README.mdにもあるように、スコア計算式は：

```
Final Score = Σ (weight_i × P(action_i))
```

**重みの特徴**:
- ポジティブアクション（いいね、リポスト、シェア）は**正の重み**
- ネガティブアクション（ブロック、ミュート、報告）は**負の重み**

**生徒**: 具体的な重みの値は公開されていますか？

**先生**: 残念ながら、実際の重み（`params`モジュール）はセキュリティ上の理由で公開されていないんだ。でも、コードの構造から**相対的な重要度の傾向**は推測できる。

**一般的な傾向**:

| アクション | 重要度の傾向 | 理由 |
|-----------|------------|------|
| ブロック・報告 | 非常に高い（負） | 深刻なネガティブシグナル |
| フォロー | 非常に高い | 長期的な関係構築 |
| 引用リツイート | 高い | 深い関与 + 拡散 |
| リプライ | 高い | 深い関与 |
| リツイート | 中〜高 | 拡散意図 |
| いいね | 中 | 基本的な肯定 |
| クリック | 中 | 興味の証拠 |
| 滞在時間 | 中 | 暗黙的関心 |
| ミュート・興味なし | 中（負） | 軽度の拒否 |

---

### 実践アドバイス: 第2章のまとめ

**先生**: この知識を活かすコツを教えよう。

1. **リプライを促す投稿を心がける**: 質問形式や議論を呼ぶ内容は、リプライ確率を高める。

2. **シェアしたくなるような価値を提供**: 情報価値が高い投稿はシェアされやすい。

3. **動画は最後まで見たくなる工夫を**: 動画視聴（VQV）は重要なシグナル。冒頭で興味を引き、最後まで見せることが大切。

4. **ネガティブアクションを避ける**: 炎上商法は逆効果。ブロックや報告が増えると、アルゴリズムに大きなペナルティを受ける。

5. **一貫した価値提供でフォローを促す**: 投稿を見た人が「フォローしたい」と思うような継続的な価値を提供しよう。

---

## 第3章: スコア計算の仕組み

### 3.1 確率予測モデルの概念

**生徒**: 先生、「P(favorite)」とか「P(reply)」って何ですか？

**先生**: これは**確率（Probability）**を表しているんだ。Phoenixモデルは、各投稿について「このユーザーがこのアクションを起こす確率」を予測しているんだよ。

**生徒**: 例えば？

**先生**: 例えば、ある投稿に対して：
- P(favorite) = 0.15 → 15%の確率でいいねする
- P(reply) = 0.03 → 3%の確率でリプライする
- P(retweet) = 0.05 → 5%の確率でリツイートする
- P(block_author) = 0.001 → 0.1%の確率でブロックする

こんな感じで**全てのアクションタイプの確率を同時に予測**しているんだ。

**生徒**: すごい！どうやってそんなことができるんですか？

**先生**: Grokベースのトランスフォーマーモデルがやっているんだ。このモデルの特徴は：

1. **ユーザーコンテキストの理解**: あなたの過去のエンゲージメント履歴（何にいいねしたか、何をリツイートしたか等）を入力として受け取る
2. **候補の隔離（Candidate Isolation）**: 複数の候補投稿を一度に処理するけど、**候補同士は互いを見られない**
3. **マルチアクション予測**: 一度の推論で全てのアクションタイプの確率を出力

**生徒**: 「候補の隔離」ってどういう意味ですか？

**先生**: これは非常に重要な設計判断だよ。アテンションマスクを使って、各候補投稿は：
- ユーザー情報と履歴は参照できる
- 他の候補投稿は参照できない

```
アテンションマスクのイメージ:

        ユーザー  履歴  候補A  候補B  候補C
候補A:    ○      ○     ○     ×     ×
候補B:    ○      ○     ×     ○     ×
候補C:    ○      ○     ×     ×     ○

○ = 参照可能、× = 参照不可
```

**生徒**: なぜそうするんですか？

**先生**: **スコアの一貫性を保つため**だよ。もし候補Aのスコアが候補Bや候補Cの存在に依存したら、同じ投稿でもバッチの組み合わせによってスコアが変わってしまう。隔離することで、**スコアがキャッシュ可能になり、一貫性が保たれる**んだ。

---

### 3.2 重み付けスコアの計算式

**生徒**: 確率が予測されたら、次はどうなるんですか？

**先生**: 「Weighted Scorer（重み付けスコアラー）」が各確率に重みをかけて合計するんだ。実際のコードを見てみよう：

```rust
fn compute_weighted_score(candidate: &PostCandidate) -> f64 {
    let s: &PhoenixScores = &candidate.phoenix_scores;

    let combined_score =
        Self::apply(s.favorite_score, p::FAVORITE_WEIGHT)
        + Self::apply(s.reply_score, p::REPLY_WEIGHT)
        + Self::apply(s.retweet_score, p::RETWEET_WEIGHT)
        + Self::apply(s.photo_expand_score, p::PHOTO_EXPAND_WEIGHT)
        + Self::apply(s.click_score, p::CLICK_WEIGHT)
        + Self::apply(s.profile_click_score, p::PROFILE_CLICK_WEIGHT)
        + Self::apply(s.vqv_score, vqv_weight)
        + Self::apply(s.share_score, p::SHARE_WEIGHT)
        + Self::apply(s.share_via_dm_score, p::SHARE_VIA_DM_WEIGHT)
        + Self::apply(s.share_via_copy_link_score, p::SHARE_VIA_COPY_LINK_WEIGHT)
        + Self::apply(s.dwell_score, p::DWELL_WEIGHT)
        + Self::apply(s.quote_score, p::QUOTE_WEIGHT)
        + Self::apply(s.quoted_click_score, p::QUOTED_CLICK_WEIGHT)
        + Self::apply(s.dwell_time, p::CONT_DWELL_TIME_WEIGHT)
        + Self::apply(s.follow_author_score, p::FOLLOW_AUTHOR_WEIGHT)
        // ネガティブアクション（負の重み）
        + Self::apply(s.not_interested_score, p::NOT_INTERESTED_WEIGHT)
        + Self::apply(s.block_author_score, p::BLOCK_AUTHOR_WEIGHT)
        + Self::apply(s.mute_author_score, p::MUTE_AUTHOR_WEIGHT)
        + Self::apply(s.report_score, p::REPORT_WEIGHT);

    Self::offset_score(combined_score)
}
```

**生徒**: `Self::apply`って何をしているんですか？

**先生**: とてもシンプルだよ：

```rust
fn apply(score: Option<f64>, weight: f64) -> f64 {
    score.unwrap_or(0.0) * weight
}
```

スコアがあれば重みをかけて、なければ0を返す。つまり：

```
単一アクションの寄与 = P(action) × weight
```

**生徒**: 数式で書くとどうなりますか？

**先生**: こうだね：

```
Final Score = Σ (weight_i × P(action_i))

= (FAVORITE_WEIGHT × P(favorite))
+ (REPLY_WEIGHT × P(reply))
+ (RETWEET_WEIGHT × P(retweet))
+ (QUOTE_WEIGHT × P(quote))
+ (SHARE_WEIGHT × P(share))
+ (CLICK_WEIGHT × P(click))
+ (DWELL_WEIGHT × P(dwell))
+ (FOLLOW_AUTHOR_WEIGHT × P(follow_author))
+ ...
+ (NOT_INTERESTED_WEIGHT × P(not_interested))  // 負の重み
+ (BLOCK_AUTHOR_WEIGHT × P(block_author))      // 負の重み
+ (MUTE_AUTHOR_WEIGHT × P(mute_author))        // 負の重み
+ (REPORT_WEIGHT × P(report))                   // 負の重み
```

**生徒**: ネガティブアクションの重みが負だから、それらの確率が高いとスコアが下がるんですね！

**先生**: 完璧に理解したね！

---

### 3.3 動画の特別な扱い

**生徒**: コードに`vqv_weight`というのがありますが、これは何ですか？

**先生**: VQVは「Video Quality View（動画クオリティビュー）」の略だ。動画投稿には特別な重みが適用されるんだよ：

```rust
fn vqv_weight_eligibility(candidate: &PostCandidate) -> f64 {
    if candidate
        .video_duration_ms
        .is_some_and(|ms| ms > p::MIN_VIDEO_DURATION_MS)
    {
        p::VQV_WEIGHT
    } else {
        0.0
    }
}
```

**生徒**: 動画の長さで判定しているんですね。

**先生**: そう。一定時間以上の動画にだけVQV重みが適用される。短すぎる動画（おそらく数秒のGIFなど）は対象外になるんだ。

---

### 3.4 スコアのオフセット処理

**生徒**: `offset_score`という関数がありますが、これは何ですか？

**先生**: これは**ネガティブスコアの処理**を行う関数だよ：

```rust
fn offset_score(combined_score: f64) -> f64 {
    if p::WEIGHTS_SUM == 0.0 {
        combined_score.max(0.0)
    } else if combined_score < 0.0 {
        (combined_score + p::NEGATIVE_WEIGHTS_SUM) / p::WEIGHTS_SUM * p::NEGATIVE_SCORES_OFFSET
    } else {
        combined_score + p::NEGATIVE_SCORES_OFFSET
    }
}
```

**生徒**: なぜこんな処理が必要なんですか？

**先生**: ネガティブアクションの影響を適切に反映するためだよ。

1. **負のスコアの場合**: 正規化して`NEGATIVE_SCORES_OFFSET`を掛ける
2. **正のスコアの場合**: `NEGATIVE_SCORES_OFFSET`を加える

これにより、**ネガティブアクションが予測される投稿は大幅にスコアが下がり**、フィードの下の方に表示されるか、完全にフィルタリングされるんだ。

---

### 3.5 なぜネガティブアクションが重要か

**生徒**: ネガティブアクションの重みが負なのは分かりましたが、なぜそこまで重要なんですか？

**先生**: 3つの重要な理由があるよ。

#### 理由1: ユーザー体験の保護

**先生**: もしユーザーが「興味なし」と言った投稿と似たコンテンツが大量に表示されたら、Xを使いたくなくなるよね。ネガティブシグナルを重視することで、**不快なコンテンツを積極的に排除**できるんだ。

**生徒**: ユーザーを守っているんですね。

#### 理由2: 悪質なコンテンツの抑制

**先生**: スパムや炎上狙いのコンテンツは、ブロックや報告が多くなる傾向がある。これらのシグナルに大きな負の重みを設定することで、**悪質なコンテンツがバイラルになるのを防ぐ**んだ。

**生徒**: アルゴリズムが品質管理もしているんですね。

#### 理由3: エコシステムの健全性

**先生**: もしネガティブシグナルを無視したら、「嫌われてもいいから注目を集める」という戦略が有効になってしまう。ネガティブアクションを重視することで、**良質なコンテンツを作るインセンティブ**を維持しているんだ。

**生徒**: 炎上商法は損するってことですね！

**先生**: その通り。実際のコードを見ると、ネガティブアクションの重みは以下のように計算に組み込まれている：

```rust
+ Self::apply(s.not_interested_score, p::NOT_INTERESTED_WEIGHT)  // 負の重み
+ Self::apply(s.block_author_score, p::BLOCK_AUTHOR_WEIGHT)      // 負の重み
+ Self::apply(s.mute_author_score, p::MUTE_AUTHOR_WEIGHT)        // 負の重み
+ Self::apply(s.report_score, p::REPORT_WEIGHT);                  // 負の重み
```

これらの`WEIGHT`定数は負の値なので、P(block_author)が0.05なら、`0.05 × (-大きな負の値)`で**大きなマイナス**になるんだ。

---

### 3.6 スコアリングパイプライン全体像

**生徒**: 重み付けスコアだけでランキングが決まるんですか？

**先生**: いい質問だ。実は、複数のスコアラーが順番に処理するんだよ：

```
スコアリングパイプライン:
1. Phoenix Scorer    → ML予測を取得
2. Weighted Scorer   → 重み付けスコアを計算
3. Author Diversity Scorer → 著者の多様性を確保
4. OON Scorer       → アウトオブネットワーク調整
```

**生徒**: Author Diversity Scorerって何ですか？

**先生**: 同じ著者の投稿が連続で表示されるのを防ぐ仕組みだよ。同じ人の投稿が続くと、**スコアが徐々に減衰**されるんだ。

**生徒**: フィードの多様性を確保しているんですね。

**先生**: そう。たとえ一人のクリエイターの投稿が全部高スコアでも、連続で表示されすぎないようにバランスを取っているんだ。

---

### 実践アドバイス: 第3章のまとめ

**先生**: この章の知識を活かすポイントをまとめよう。

1. **全てのアクションが予測される**: いいねだけでなく、クリック、滞在時間、フォロー確率まで予測されている。**総合的に良い反応を得られる**コンテンツを目指そう。

2. **ネガティブアクションを最小化する**: ブロックや報告が増えると大きなペナルティ。**炎上よりも共感を**目指した方が長期的に有利。

3. **シェアされやすいコンテンツを意識**: シェア系のスコアは複数種類ある（DM、コピーリンク等）。「他の人にも見せたい」と思わせる価値を提供しよう。

4. **フォロー確率を意識**: 「この人フォローしたい」と思わせる一貫した価値提供が重要。一発屋より継続的なクリエイターが有利。

5. **動画は長さと内容のバランス**: VQV重みは一定時間以上の動画に適用される。意味のある長さの、最後まで見たくなる動画を作ろう。

---

## 次章予告

**先生**: お疲れ様。第1章から第3章で、Xアルゴリズムの基本的な仕組みを理解できたね。

**生徒**: ありがとうございます！アルゴリズムが何を見ているか、よく分かりました。

**先生**: 次の章では以下を学ぶよ：
- **第4章**: フィルタリングの仕組み（なぜ一部の投稿が表示されないか）
- **第5章**: 著者の多様性と品質管理
- **第6章**: 実践的な最適化戦略

**生徒**: 楽しみです！

---

## 参考資料

このガイドは以下のソースコードに基づいています：

- `/Users/funakoshiakira/workspace/x-algorithm/README.md` - システム全体のアーキテクチャ
- `/Users/funakoshiakira/workspace/x-algorithm/phoenix/README.md` - Phoenixモデルの詳細
- `/Users/funakoshiakira/workspace/x-algorithm/home-mixer/scorers/weighted_scorer.rs` - 重み付けスコア計算
- `/Users/funakoshiakira/workspace/x-algorithm/home-mixer/candidate_pipeline/candidate.rs` - PhoenixScores構造体
